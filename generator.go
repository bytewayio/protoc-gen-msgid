package main

import (
	"bytes"
	"strings"

	"fmt"

	"path"

	"sort"

	"log"
	"os"

	protobuf "google.golang.org/protobuf/types/descriptorpb"
	plugin "google.golang.org/protobuf/types/pluginpb"
)

const (
	targetCmd     string = "cmd"
	targetPackMsg string = "packmsg"
	targetPackObj string = "packobj"
	targetUnpack  string = "unpack"
	targetAs      string = "as"
	targetJava    string = "java"
	targetCs      string = "csharp"
	targetTs      string = "ts"
)

// Generator the auto code generator
type Generator struct {
	Request      *plugin.CodeGeneratorRequest
	Response     *plugin.CodeGeneratorResponse
	Params       map[string]string
	typesMapping map[string]string
}

// NewGenerator create a new code generator
func NewGenerator() *Generator {
	g := new(Generator)
	g.Request = new(plugin.CodeGeneratorRequest)
	g.Response = new(plugin.CodeGeneratorResponse)
	g.Params = make(map[string]string)
	g.typesMapping = make(map[string]string)
	g.typesMapping["TYPE_DOUBLE"] = "float64"
	g.typesMapping["TYPE_FLOAT"] = "float32"
	g.typesMapping["TYPE_INT32"] = "int32"
	g.typesMapping["TYPE_INT64"] = "int64"
	g.typesMapping["TYPE_UINT32"] = "uint32"
	g.typesMapping["TYPE_UINT64"] = "uint64"
	g.typesMapping["TYPE_SINT32"] = "int32"
	g.typesMapping["TYPE_SINT64"] = "int64"
	g.typesMapping["TYPE_FIXED32"] = "uint32"
	g.typesMapping["TYPE_FIXED64"] = "uint64"
	g.typesMapping["TYPE_SFIXED32"] = "int32"
	g.typesMapping["TYPE_SFIXED64"] = "int64"
	g.typesMapping["TYPE_BOOL"] = "bool"
	g.typesMapping["TYPE_STRING"] = "string"
	g.typesMapping["TYPE_BYTES"] = "[]byte"
	return g
}

// LoadParams load params from request
func (g *Generator) LoadParams() {
	for _, v := range strings.Split(g.Request.GetParameter(), ",") {
		if i := strings.Index(v, "="); i < 0 {
			g.Params[v] = "true"
		} else {
			g.Params[v[0:i]] = v[i+1:]
		}
	}
}

// GenerateFiles Generate Entrance
func (g *Generator) GenerateFiles() {
	flags := make([]bool, 8)
	_, flags[0] = g.Params[targetAs]
	_, flags[1] = g.Params[targetCmd]
	_, flags[2] = g.Params[targetPackMsg]
	_, flags[3] = g.Params[targetPackObj]
	_, flags[4] = g.Params[targetUnpack]
	_, flags[5] = g.Params[targetJava]
	_, flags[6] = g.Params[targetCs]
	_, flags[7] = g.Params[targetTs]

	filesToGen := 0
	for _, v := range flags {
		if v {
			filesToGen++
		}
	}

	if filesToGen == 0 {
		log.Println("please specify which files to be generated, candidates: cmd,pack,unpack,as,csharp or ts")
		os.Exit(1)
	}

	g.Response.File = make([]*plugin.CodeGeneratorResponse_File, len(g.Request.ProtoFile)*filesToGen)
	responseFileIndex := 0
	for _, file := range g.Request.ProtoFile {
		sort.Sort(ByMsgTypeName(file.MessageType))
		if flags[1] { // generate cmd file
			g.Response.File[responseFileIndex] = g.generateCmdFile(file)
			responseFileIndex++
		}

		if flags[2] { // generate pack file
			g.Response.File[responseFileIndex] = g.generatePackFile(file)
			responseFileIndex++
		}

		if flags[3] { // generate packObj file
			g.Response.File[responseFileIndex] = g.generatePackObjFile(file)
			responseFileIndex++
		}

		if flags[4] { // generate unpack file
			g.Response.File[responseFileIndex] = g.generateUnpackFile(file)
			responseFileIndex++
		}

		if flags[0] { // generate as file
			g.Response.File[responseFileIndex] = g.generateAsFile(file)
			responseFileIndex++
		}

		if flags[5] { // generate java file
			g.Response.File[responseFileIndex] = g.generateJavaFile(file)
			responseFileIndex++
		}

		if flags[6] { // generate csharp file
			g.Response.File[responseFileIndex] = g.generateCSharpFile(file)
			responseFileIndex++
		}

		if flags[7] { // generate typescript file
			g.Response.File[responseFileIndex] = g.generateTypeScriptFile(file)
			responseFileIndex++
		}
	}
}

func (g *Generator) generateHeader(buf *bytes.Buffer, file *protobuf.FileDescriptorProto) {
	buf.WriteString("// Code generated by protoc-gen-gocmd.\n")
	buf.WriteString("// source: ")
	buf.WriteString(*file.Name)
	buf.WriteByte('\n')
	buf.WriteString("// DO NOT EDIT!\n")
	buf.WriteByte('\n')
	buf.WriteString("package ")
	buf.WriteString(*file.Package)
	buf.WriteByte('\n')
	buf.WriteByte('\n')
}

func (g *Generator) generateUnpackFile(file *protobuf.FileDescriptorProto) *plugin.CodeGeneratorResponse_File {
	tab := "    " // 4 spaces for tab by default
	if _, ok := g.Params["usetabs"]; ok {
		tab = "\t"
	}

	buf := new(bytes.Buffer)
	g.generateHeader(buf, file)
	buf.WriteString("import(\n")
	buf.WriteString(tab)
	buf.WriteString("\"errors\"\n")
	buf.WriteString(")\n")
	buf.WriteByte('\n')
	buf.WriteString("func Unpack(fromCmd int16, data []byte) (interface{}, error) {\n")
	buf.WriteString(tab)
	buf.WriteString("switch fromCmd {\n")
	for _, msg := range file.GetMessageType() {
		typeName := msg.GetName()
		// if !g.isMessageCandidate(typeName) {
		// 	continue
		// }

		buf.WriteString(tab)
		buf.WriteString("case Cmd_")
		buf.WriteString(typeName)
		buf.WriteString(":\n")
		buf.WriteString(tab)
		buf.WriteString(tab)
		buf.WriteString("pb := &")
		buf.WriteString(typeName)
		buf.WriteString("{}\n")
		buf.WriteString(tab)
		buf.WriteString(tab)
		buf.WriteString("err := pb.Unmarshal(data)\n")
		buf.WriteString(tab)
		buf.WriteString(tab)
		buf.WriteString("return pb, err\n\n")
	}

	buf.WriteString(tab)
	buf.WriteString("default:\n")
	buf.WriteString(tab)
	buf.WriteString(tab)
	buf.WriteString("return nil, errors.New(\"Unhandle Cmd\")\n")
	buf.WriteString(tab)
	buf.WriteString("}\n}")

	response := new(plugin.CodeGeneratorResponse_File)
	fileSuffix := path.Ext(*file.Name)
	generatedFileName := ((*file.Name)[0:len(*file.Name)-len(fileSuffix)] + ".unpack.go")
	fileContent := buf.String()
	response.Name = &generatedFileName
	response.Content = &fileContent
	return response
}

func (g *Generator) generatePackObjFile(file *protobuf.FileDescriptorProto) *plugin.CodeGeneratorResponse_File {
	tab := "    " // 4 spaces for tab by default
	if _, ok := g.Params["usetabs"]; ok {
		tab = "\t"
	}

	buf := new(bytes.Buffer)
	isFirstMsg := true
	g.generateHeader(buf, file)
	buf.WriteString("import \"github.com/gogo/protobuf/proto\"\n\n")

	for _, msg := range file.GetMessageType() {
		if !isFirstMsg {
			buf.WriteByte('\n')
		}

		isFirstArgument := true
		assignmentBuf := new(bytes.Buffer)
		msgTypeName := msg.GetName()

		buf.WriteString("func NewObj")

		buf.WriteString(msgTypeName)
		buf.WriteByte('(')
		for _, field := range msg.GetField() {
			if !isFirstArgument {
				buf.WriteString(", ")
			}

			argumentName := field.GetName()
			buf.WriteString(argumentName)
			buf.WriteByte(' ')
			typeName, builtinType := g.typesMapping[field.GetType().String()]
			repeatedField := field.GetLabel().String() == "LABEL_REPEATED"
			if !builtinType {
				typeName = "*" + field.GetTypeName()[strings.LastIndex(field.GetTypeName(), ".")+1:]
			}

			if repeatedField {
				typeName = "[]" + typeName
			}

			buf.WriteString(typeName)

			assignmentBuf.WriteString(tab)
			assignmentBuf.WriteString(tab)
			assignmentBuf.WriteString(argumentName)
			assignmentBuf.WriteString(": ")
			if builtinType && !strings.HasPrefix(typeName, "[]") {
				assignmentBuf.WriteString("proto.")
				assignmentBuf.WriteString(typeName)
				assignmentBuf.WriteByte('(')
				assignmentBuf.WriteString(argumentName)
				assignmentBuf.WriteString("),\n")
			} else {
				assignmentBuf.WriteString(argumentName)
				assignmentBuf.WriteString(",\n")
			}

			if isFirstArgument {
				isFirstArgument = false
			}
		}
		buf.WriteByte(')')
		buf.WriteString(" *")
		buf.WriteString(msgTypeName)
		buf.WriteString(" {\n")

		buf.WriteString(tab)
		buf.WriteString("return &")
		buf.WriteString(msgTypeName)
		if assignmentBuf.Len() > 0 {
			buf.WriteString("{\n")
			buf.WriteString(assignmentBuf.String())
			buf.WriteString(tab)
			buf.WriteString("}\n")
		} else {
			buf.WriteString("{}\n")
		}
		buf.WriteString("}\n")
		if isFirstMsg {
			isFirstMsg = false
		}
	}

	response := new(plugin.CodeGeneratorResponse_File)
	fileSuffix := path.Ext(*file.Name)
	generatedFileName := ((*file.Name)[0:len(*file.Name)-len(fileSuffix)] + ".packobj.go")
	fileContent := buf.String()
	response.Name = &generatedFileName
	response.Content = &fileContent
	return response
}

func (g *Generator) generatePackFile(file *protobuf.FileDescriptorProto) *plugin.CodeGeneratorResponse_File {
	tab := "    " // 4 spaces for tab by default
	if _, ok := g.Params["usetabs"]; ok {
		tab = "\t"
	}

	buf := new(bytes.Buffer)
	isFirstMsg := true
	g.generateHeader(buf, file)
	buf.WriteString("import(\n")
	buf.WriteString(tab)
	buf.WriteString("\"log\"\n")
	buf.WriteString(tab)
	buf.WriteString("\"github.com/gogo/protobuf/proto\"\n")
	buf.WriteString(")\n")
	buf.WriteByte('\n')

	for _, msg := range file.GetMessageType() {
		if !isFirstMsg {
			buf.WriteByte('\n')
		}

		isFirstArgument := true
		assignmentBuf := new(bytes.Buffer)
		msgTypeName := msg.GetName()

		buf.WriteString("func ")
		buf.WriteString("NewMsg")

		buf.WriteString(msgTypeName)
		buf.WriteByte('(')
		for _, field := range msg.GetField() {
			if !isFirstArgument {
				buf.WriteString(", ")
			}

			argumentName := field.GetName()
			buf.WriteString(argumentName)
			buf.WriteByte(' ')
			typeName, builtinType := g.typesMapping[field.GetType().String()]
			repeatedField := field.GetLabel().String() == "LABEL_REPEATED"
			if !builtinType {
				typeName = "*" + field.GetTypeName()[strings.LastIndex(field.GetTypeName(), ".")+1:]
			}

			if repeatedField {
				typeName = "[]" + typeName
			}

			buf.WriteString(typeName)

			assignmentBuf.WriteString(tab)
			assignmentBuf.WriteString(tab)
			assignmentBuf.WriteString(argumentName)
			assignmentBuf.WriteString(": ")
			if builtinType && !strings.HasPrefix(typeName, "[]") {
				assignmentBuf.WriteString("proto.")
				assignmentBuf.WriteString(typeName)
				assignmentBuf.WriteByte('(')
				assignmentBuf.WriteString(argumentName)
				assignmentBuf.WriteString("),\n")
			} else {
				assignmentBuf.WriteString(argumentName)
				assignmentBuf.WriteString(",\n")
			}

			if isFirstArgument {
				isFirstArgument = false
			}
		}
		buf.WriteByte(')')
		buf.WriteString(" []byte {\n")

		buf.WriteString(tab)
		buf.WriteString("obj := &")
		buf.WriteString(msgTypeName)
		if assignmentBuf.Len() > 0 {
			buf.WriteString("{\n")
			buf.WriteString(assignmentBuf.String())
			buf.WriteString(tab)
			buf.WriteString("}\n")
		} else {
			buf.WriteString("{}\n")
		}

		// generate marshal code
		buf.WriteString(tab)
		buf.WriteString("if data, err := obj.Marshal(); err != nil {\n")
		buf.WriteString(tab)
		buf.WriteString(tab)
		buf.WriteString("log.Println(")
		buf.WriteString("\"failed to marshal ")
		buf.WriteString(msgTypeName)
		buf.WriteString(" due to error \", err.Error())\n")
		buf.WriteString(tab)
		buf.WriteString(tab)
		buf.WriteString("return nil\n")
		buf.WriteString(tab)
		buf.WriteString("} else {\n")
		buf.WriteString(tab)
		buf.WriteString(tab)
		buf.WriteString("return data\n")
		buf.WriteString(tab)
		buf.WriteString("}\n")

		buf.WriteString("}\n")
		if isFirstMsg {
			isFirstMsg = false
		}
	}

	response := new(plugin.CodeGeneratorResponse_File)
	fileSuffix := path.Ext(*file.Name)
	generatedFileName := ((*file.Name)[0:len(*file.Name)-len(fileSuffix)] + ".packmsg.go")
	fileContent := buf.String()
	response.Name = &generatedFileName
	response.Content = &fileContent
	return response
}

func (g *Generator) generateCmdFile(file *protobuf.FileDescriptorProto) *plugin.CodeGeneratorResponse_File {
	buf := new(bytes.Buffer)
	g.generateHeader(buf, file)
	messageCount := len(file.MessageType)
	messageIDOffset := 0x1000
	for messageIDOffset < messageCount {
		messageIDOffset <<= 4
	}

	messageID := messageIDOffset + 1
	for _, v := range file.GetMessageType() {
		buf.WriteString("const Cmd_")
		buf.WriteString(v.GetName())
		buf.WriteString(fmt.Sprintf(" = 0x%X\n", messageID))
		messageID++
	}

	response := new(plugin.CodeGeneratorResponse_File)
	fileSuffix := path.Ext(*file.Name)
	generatedFileName := ((*file.Name)[0:len(*file.Name)-len(fileSuffix)] + ".cmd.go")
	fileContent := buf.String()
	response.Name = &generatedFileName
	response.Content = &fileContent
	return response
}

func (g *Generator) generateAsFile(file *protobuf.FileDescriptorProto) *plugin.CodeGeneratorResponse_File {
	buf := new(bytes.Buffer)
	ns, hasNs := g.Params["asns"]
	if !hasNs {
		if file.Options != nil {
			ns = file.Options.GetJavaPackage()
		}

		if len(ns) == 0 {
			ns = file.GetPackage()
		}
	}

	tab := "    " // 4 spaces for tab by default
	if _, ok := g.Params["usetabs"]; ok {
		tab = "\t"
	}

	buf.WriteString("// Code generated by protoc-gen-gocmd.\n")
	buf.WriteString("// source: ")
	buf.WriteString(*file.Name)
	buf.WriteByte('\n')
	buf.WriteString("// DO NOT EDIT!\n")
	buf.WriteByte('\n')
	buf.WriteString("package ")
	buf.WriteString(ns)
	buf.WriteString("\n{\n")
	buf.WriteString(tab)
	buf.WriteString("public class ProtocolType{\n")
	messageCount := len(file.MessageType)
	messageIDOffset := 0x1000
	for messageIDOffset < messageCount {
		messageIDOffset <<= 4
	}

	messageID := messageIDOffset + 1
	for _, msg := range file.GetMessageType() {
		buf.WriteString(tab)
		buf.WriteString(tab)
		buf.WriteString("public static const ")
		buf.WriteString(msg.GetName())
		buf.WriteString(fmt.Sprintf(" : int = 0x%X;\n", messageID))
		messageID++
	}

	buf.WriteString(tab)
	buf.WriteString("}\n}\n")
	response := new(plugin.CodeGeneratorResponse_File)
	generatedFileName := "ProtocolType.as"
	fileContent := buf.String()
	response.Name = &generatedFileName
	response.Content = &fileContent
	return response
}

func (g *Generator) generateJavaFile(file *protobuf.FileDescriptorProto) *plugin.CodeGeneratorResponse_File {
	buf := new(bytes.Buffer)
	pkg, hasPkg := g.Params["pkg"]
	if !hasPkg {
		if file.Options != nil {
			pkg = file.Options.GetJavaPackage()
		}

		if len(pkg) == 0 {
			pkg = file.GetPackage()
		}
	}

	tab := "    " // 4 spaces for tab by default
	if _, ok := g.Params["usetabs"]; ok {
		tab = "\t"
	}

	buf.WriteString("// Code generated by protoc-gen-gocmd.\n")
	buf.WriteString("// source: ")
	buf.WriteString(*file.Name)
	buf.WriteByte('\n')
	buf.WriteString("// DO NOT EDIT!\n")
	buf.WriteByte('\n')
	buf.WriteString("package ")
	buf.WriteString(pkg)
	buf.WriteString(";\n\n")
	buf.WriteString("import java.util.Map;\n")
	buf.WriteString("import java.util.HashMap;\n\n")
	buf.WriteString("public class MessageTypes {\n")
	messageCount := len(file.MessageType)
	messageIDOffset := 0x1000
	for messageIDOffset < messageCount {
		messageIDOffset <<= 4
	}

	messageID := messageIDOffset + 1
	for _, msg := range file.GetMessageType() {
		buf.WriteString(tab)
		buf.WriteString("public static final int ")
		buf.WriteString(msg.GetName())
		buf.WriteString(fmt.Sprintf(" = 0x%X;\n", messageID))
		messageID++
	}

	buf.WriteString("\n")
	buf.WriteString(tab)
	buf.WriteString("private static Map<Integer, String> messageTypeToMessageNameMapping = new HashMap<Integer, String>();\n")
	buf.WriteString("private static Map<String, Integer> messageNameToMessageTypeMapping = new HashMap<String, Integer>();\n\n")
	buf.WriteString(tab)
	buf.WriteString("static {\n")
	for _, msg := range file.GetMessageType() {
		buf.WriteString(tab)
		buf.WriteString(tab)
		buf.WriteString("messageTypeToMessageNameMapping.put(")
		buf.WriteString(msg.GetName())
		buf.WriteString(", \"")
		buf.WriteString(msg.GetName())
		buf.WriteString("\");\n")
		buf.WriteString(tab)
		buf.WriteString(tab)
		buf.WriteString("messageNameToMessageTypeMapping.put(\"")
		buf.WriteString(msg.GetName())
		buf.WriteString("\", ")
		buf.WriteString(msg.GetName())
		buf.WriteString(");\n")
	}
	buf.WriteString(tab)
	buf.WriteString("}\n\n")
	buf.WriteString(tab)
	buf.WriteString("public static String getMessageTypeName(int messageTypeId) {\n")
	buf.WriteString(tab)
	buf.WriteString(tab)
	buf.WriteString("return messageTypeToMessageNameMapping.get(messageTypeId);\n")
	buf.WriteString(tab)
	buf.WriteString("}\n\n")
	buf.WriteString(tab)
	buf.WriteString("public static Integer getMessageTypeId(String messageTypeName) {\n")
	buf.WriteString(tab)
	buf.WriteString(tab)
	buf.WriteString("return messageNameToMessageTypeMapping.get(messageTypeName);\n")
	buf.WriteString(tab)
	buf.WriteString("}\n")
	buf.WriteString("}\n")
	response := new(plugin.CodeGeneratorResponse_File)
	generatedFileName := "MessageTypes.java"
	fileContent := buf.String()
	response.Name = &generatedFileName
	response.Content = &fileContent
	return response
}

func (g *Generator) generateCSharpFile(file *protobuf.FileDescriptorProto) *plugin.CodeGeneratorResponse_File {
	buf := new(bytes.Buffer)
	ns, hasNs := g.Params["ns"]
	if !hasNs {
		if file.Options != nil {
			ns = file.Options.GetCsharpNamespace()
		}

		if len(ns) == 0 {
			ns = file.GetPackage()
		}
	}

	tab := "    " // 4 spaces for tab by default
	if _, ok := g.Params["usetabs"]; ok {
		tab = "\t"
	}

	buf.WriteString("// Code generated by protoc-gen-gocmd.\n")
	buf.WriteString("// source: ")
	buf.WriteString(*file.Name)
	buf.WriteString("\n")
	buf.WriteString("// DO NOT EDIT!\n")
	buf.WriteString("\n")
	buf.WriteString("namespace ")
	buf.WriteString(ns)
	buf.WriteString(" {\n")
	buf.WriteString(tab)
	buf.WriteString("public enum MessageTypes : int {\n")
	messageCount := len(file.MessageType)
	messageIDOffset := 0x1000
	for messageIDOffset < messageCount {
		messageIDOffset <<= 4
	}

	messageID := messageIDOffset + 1
	for _, msg := range file.GetMessageType() {
		buf.WriteString(tab)
		buf.WriteString(tab)
		buf.WriteString(msg.GetName())
		buf.WriteString(fmt.Sprintf(" = 0x%X,\n", messageID))
		messageID++
	}

	buf.WriteString(tab)
	buf.WriteString("}\n")
	buf.WriteString("}\n")

	response := new(plugin.CodeGeneratorResponse_File)
	generatedFileName := "MessageTypes.cs"
	fileContent := buf.String()
	response.Name = &generatedFileName
	response.Content = &fileContent
	return response
}

func (g *Generator) generateTypeScriptFile(file *protobuf.FileDescriptorProto) *plugin.CodeGeneratorResponse_File {
	buf := new(bytes.Buffer)
	ns, hasNs := g.Params["ns"]
	if !hasNs {
		if file.Options != nil {
			ns = file.Options.GetCsharpNamespace()
		}

		if len(ns) == 0 {
			ns = file.GetPackage()
		}
	}

	tab := "    " // 4 spaces for tab by default
	if _, ok := g.Params["usetabs"]; ok {
		tab = "\t"
	}

	buf.WriteString("// Code generated by protoc-gen-gocmd.\n")
	buf.WriteString("// source: ")
	buf.WriteString(*file.Name)
	buf.WriteString("\n")
	buf.WriteString("// DO NOT EDIT!\n")
	buf.WriteString("\n")
	buf.WriteString("namespace ")
	buf.WriteString(ns)
	buf.WriteString(" {\n")
	buf.WriteString(tab)
	buf.WriteString("export enum MessageTypes {\n")
	messageCount := len(file.MessageType)
	messageIDOffset := 0x1000
	for messageIDOffset < messageCount {
		messageIDOffset <<= 4
	}

	messageID := messageIDOffset + 1
	for _, msg := range file.GetMessageType() {
		buf.WriteString(tab)
		buf.WriteString(tab)
		buf.WriteString(msg.GetName())
		buf.WriteString(fmt.Sprintf(" = 0x%X,\n", messageID))
		messageID++
	}

	buf.WriteString(tab)
	buf.WriteString("}\n")
	buf.WriteString("}\n")

	response := new(plugin.CodeGeneratorResponse_File)
	generatedFileName := "MessageTypes.ts"
	fileContent := buf.String()
	response.Name = &generatedFileName
	response.Content = &fileContent
	return response
}

// ByMsgTypeName sort all message types by name, so the protoId will be the same for each type of message in different runs
type ByMsgTypeName []*protobuf.DescriptorProto

func (t ByMsgTypeName) Len() int {
	return len(t)
}

func (t ByMsgTypeName) Swap(i, j int) {
	t[i], t[j] = t[j], t[i]
}

func (t ByMsgTypeName) Less(i, j int) bool {
	return strings.Compare(*t[i].Name, *t[j].Name) < 0
}
